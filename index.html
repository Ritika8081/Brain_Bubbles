<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brainwave Balloon Game</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    .container {
      position: relative;
      width: 100%;
      max-width: 800px;
      height: 70vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .sky {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .balloon-container {
      position: relative;
      z-index: 10;
      margin-bottom: 50px;
    }

    .balloon {
      width: 100px;
      height: 120px;
      background-color: #ff6b6b;
      border-radius: 50%;
      position: relative;
      transition: transform 0.3s ease-out;
      box-shadow: inset -10px -10px 20px rgba(0,0,0,0.2);
    }

    .balloon-string {
      position: absolute;
      top: 100%;
      left: 50%;
      width: 2px;
      height: 80px;
      background-color: #333;
    }

    .controls {
      width: 100%;
      max-width: 600px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      z-index: 20;
    }

    .slider-container {
      margin-bottom: 15px;
    }

    .slider-container label {
      display: inline-block;
      width: 150px;
      font-weight: bold;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin: 15px 0;
    }

    button {
      padding: 8px 15px;
      border: none;
      border-radius: 5px;
      background-color: #4a76fd;
      color: white;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #3a66ed;
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .brain-wave-display {
      margin-top: 15px;
    }

    .wave-bar {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .wave-label {
      width: 80px;
      font-weight: bold;
      font-size: 14px;
    }

    .wave-outer {
      flex-grow: 1;
      height: 20px;
      background-color: #f0f0f0;
      border-radius: 10px;
      overflow: hidden;
    }

    .wave-inner {
      height: 100%;
      border-radius: 10px;
      transition: width 0.3s ease;
    }

    #deltaBar { background-color: #FF5733; }
    #thetaBar { background-color: #33FF57; }
    #alphaBar { background-color: #3357FF; }
    #betaBar { background-color: #FF33F5; }
    #gammaBar { background-color: #F5FF33; }

    .wave-value {
      width: 50px;
      text-align: right;
      padding-left: 10px;
      font-size: 14px;
    }

    .bubble {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(173, 216, 230, 0.4));
      animation: float 2s ease-out forwards;
      z-index: 5;
    }

    @keyframes float {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 0.7;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0.5);
        opacity: 0;
      }
    }

    .status {
      margin-top: 10px;
      font-weight: bold;
      color: #333;
    }

    .game-score {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px 15px;
      border-radius: 10px;
      font-weight: bold;
      z-index: 30;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="sky"></div>
    <div class="balloon-container">
      <div class="balloon"></div>
      <div class="balloon-string"></div>
    </div>
    <div class="game-score">Score: <span id="scoreValue">0</span></div>
  </div>

  <div class="controls">
    <div class="slider-container">
      <label for="betaThresholdSlider">Beta Threshold:</label>
      <input type="range" id="betaThresholdSlider" min="0.1" max="0.7" step="0.01" value="0.4">
      <span id="betaThresholdValue">0.40</span>
    </div>

    <div class="button-group">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <button id="startBtn" disabled>Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>

    <div class="status">Status: <span id="statusText">Not connected</span></div>

    <div class="brain-wave-display">
      <div class="wave-bar">
        <div class="wave-label">Delta:</div>
        <div class="wave-outer"><div id="deltaBar" class="wave-inner" style="width: 0%"></div></div>
        <div id="deltaValue" class="wave-value">0%</div>
      </div>
      <div class="wave-bar">
        <div class="wave-label">Theta:</div>
        <div class="wave-outer"><div id="thetaBar" class="wave-inner" style="width: 0%"></div></div>
        <div id="thetaValue" class="wave-value">0%</div>
      </div>
      <div class="wave-bar">
        <div class="wave-label">Alpha:</div>
        <div class="wave-outer"><div id="alphaBar" class="wave-inner" style="width: 0%"></div></div>
        <div id="alphaValue" class="wave-value">0%</div>
      </div>
      <div class="wave-bar">
        <div class="wave-label">Beta:</div>
        <div class="wave-outer"><div id="betaBar" class="wave-inner" style="width: 0%"></div></div>
        <div id="betaValue" class="wave-value">0%</div>
      </div>
      <div class="wave-bar">
        <div class="wave-label">Gamma:</div>
        <div class="wave-outer"><div id="gammaBar" class="wave-inner" style="width: 0%"></div></div>
        <div id="gammaValue" class="wave-value">0%</div>
      </div>
    </div>
  </div>

  <script>
    // DOM elements
    const balloon = document.querySelector('.balloon');
    const container = document.querySelector('.container');
    const betaThresholdSlider = document.getElementById('betaThresholdSlider');
    const betaThresholdValue = document.getElementById('betaThresholdValue');
    const connectBtn = document.getElementById("connectBtn");
    const disconnectBtn = document.getElementById("disconnectBtn");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const statusText = document.getElementById("statusText");
    const scoreValue = document.getElementById("scoreValue");
    
    // Game variables
    let score = 0;
    let balloonSize = 1.0;
    let inflating = false;
    let lastBetaValue = 0;
    let betaThreshold = 0.40;  // initial threshold
    let lastBubbleTime = 0;
    const BUBBLE_COOLDOWN = 300; // ms between bubble bursts
    const MAX_BALLOON_SIZE = 2.5;
    const MIN_BALLOON_SIZE = 1.0;
    const INFLATION_RATE = 0.05;
    const DEFLATION_RATE = 0.02;
    
    // BLE constants
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const DATA_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    const CONTROL_CHAR_UUID = "0000ff01-0000-1000-8000-00805f9b34fb";
    const SINGLE_SAMPLE_LEN = 7, BLOCK_COUNT = 10;
    const NEW_PACKET_LEN = SINGLE_SAMPLE_LEN * BLOCK_COUNT;
    
    // EEG processing constants
    const FFT_SIZE = 256;
    const SAMPLE_RATE = 500;
    const FREQ_RESOLUTION = SAMPLE_RATE / FFT_SIZE;
    const DELTA_RANGE = [0.5, 4];
    const THETA_RANGE = [4, 8];
    const ALPHA_RANGE = [8, 12];
    const BETA_RANGE = [12, 30];
    const GAMMA_RANGE = [30, 100];
    
    // Variables for BLE connection
    let device = null, server = null, controlChar = null, dataChar = null;
    let streaming = false, connected = false;
    let prevSampleCounter = null, samplesReceived = 0;
    
    // Variables for EEG processing
    let fftBuffer = new Array(FFT_SIZE).fill(0);
    let filterStateCh0 = { z1: 0, z2: 0, x1: 0 };
    
    // Buffer for smoothing beta values
    let buffer_size = 64;
    let circular_buffer = new Array(buffer_size).fill(0);
    let data_index = 0, sum = 0;
    
    // Notch filter for 50Hz noise
    class Notch {
      constructor() {
        this.z1_1 = 0; this.z2_1 = 0;
        this.x_1 = 0;
        this.currentSamplingRate = 500;
      }
      setSamplingRate(rate) { this.currentSamplingRate = rate; }
      process(input, type) {
        if (!type) return input;
        let output = input;
        // Simple example: 50Hz notch for 500Hz
        if (this.currentSamplingRate === 500 && type === 1) {
          this.x_1 = output - (-1.56858163 * this.z1_1) - (0.96424138 * this.z2_1);
          output = 0.96508099 * this.x_1 + -1.56202714 * this.z1_1 + 0.96508099 * this.z2_1;
          this.z2_1 = this.z1_1;
          this.z1_1 = this.x_1;
        }
        return output;
      }
    }
    let notchFilterCh0 = new Notch();
    notchFilterCh0.setSamplingRate(500);

    // FFT implementation
    class FFT {
      constructor(size) {
        this.size = size;
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
          this.cosTable[i] = Math.cos(-2 * Math.PI * i / size);
          this.sinTable[i] = Math.sin(-2 * Math.PI * i / size);
        }
      }
      computeMagnitudes(input) {
        const real = new Float32Array(this.size);
        const imag = new Float32Array(this.size);
        for (let i = 0; i < input.length && i < this.size; i++) {
          real[i] = input[i];
        }
        this.fft(real, imag);
        const mags = new Float32Array(this.size / 2);
        for (let i = 0; i < this.size / 2; i++) {
          mags[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / (this.size / 2);
        }
        return mags;
      }
      fft(real, imag) {
        const n = this.size;
        let j = 0;
        for (let i = 0; i < n - 1; i++) {
          if (i < j) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], real[i]];
          }
          let k = n / 2;
          while (k <= j) { j -= k; k /= 2; }
          j += k;
        }
        for (let l = 2; l <= n; l *= 2) {
          const le2 = l / 2;
          for (let k = 0; k < le2; k++) {
            const kth = k * (n / l);
            const c = this.cosTable[kth], s = this.sinTable[kth];
            for (let i = k; i < n; i += l) {
              const i2 = i + le2;
              const tr = c * real[i2] - s * imag[i2];
              const ti = c * imag[i2] + s * real[i2];
              real[i2] = real[i] - tr;
              imag[i2] = imag[i] - ti;
              real[i] += tr;
              imag[i] += ti;
            }
          }
        }
      }
    }
    const fftProcessor = new FFT(FFT_SIZE);
    
    // Update threshold value from slider
    betaThresholdSlider.addEventListener('input', (e) => {
      betaThreshold = parseFloat(e.target.value);
      betaThresholdValue.textContent = betaThreshold.toFixed(2);
    });
    
    // Main game function: update balloon based on beta values
    function updateBalloon(betaRel) {
      // Update previous beta value
      const betaDiff = betaRel - lastBetaValue;
      lastBetaValue = betaRel;
      
      // Determine if we should inflate or deflate
      if (betaRel >= betaThreshold) {
        // Inflate balloon
        if (!inflating) {
          inflating = true;
        }
        
        balloonSize += INFLATION_RATE;
        if (balloonSize > MAX_BALLOON_SIZE) {
          balloonSize = MAX_BALLOON_SIZE;
          // Add points when reaching max size
          score += 10;
          scoreValue.textContent = score;
        }
      } else {
        // Deflate balloon
        if (inflating) {
          inflating = false;
          // Create deflation bubbles
          createDeflationBubbles();
        }
        
        balloonSize -= DEFLATION_RATE;
        if (balloonSize < MIN_BALLOON_SIZE) {
          balloonSize = MIN_BALLOON_SIZE;
        }
      }
      
      // Update balloon size
      balloon.style.transform = `scale(${balloonSize})`;
      
      // Create bubbles during deflation
      if (!inflating && betaDiff < -0.02) {
        createBubbleEffect();
      }
    }
    
    // Create bubbles during deflation
    function createBubbleEffect() {
      const now = Date.now();
      if (now - lastBubbleTime < BUBBLE_COOLDOWN) return;
      lastBubbleTime = now;
      
      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      
      // Bubble size
      const size = Math.floor(Math.random() * 10) + 5;
      bubble.style.width = `${size}px`;
      bubble.style.height = `${size}px`;
      
      // Position bubble at bottom of balloon
      const balloonRect = balloon.getBoundingClientRect();
      const startX = balloonRect.left + balloonRect.width / 2 - size / 2;
      const startY = balloonRect.bottom - size / 2;
      
      bubble.style.left = `${startX}px`;
      bubble.style.top = `${startY}px`;
      
      // Set random direction for bubble
      const angle = Math.random() * Math.PI / 2 + Math.PI / 4; // 45-135 degrees
      const distance = 50 + Math.random() * 100;
      const tx = Math.cos(angle) * distance * (Math.random() > 0.5 ? 1 : -1);
      const ty = Math.sin(angle) * distance;
      
      bubble.style.setProperty('--tx', `${tx}px`);
      bubble.style.setProperty('--ty', `${ty}px`);
      
      // Remove bubble after animation
      bubble.addEventListener('animationend', () => {
        bubble.remove();
      });
      
      document.body.appendChild(bubble);
    }
    
    // Create multiple bubbles when transitioning from inflating to deflating
    function createDeflationBubbles() {
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          createBubbleEffect();
        }, i * 100);
      }
    }
    
    // Utility functions from the original code
    function normalizeSample(sample) {
      const a = 4096;
      return (sample - a / 2) * (2 / a);
    }
    
    function applyFilter(input, state) {
      state.x1 = input - (-1.47548044 * state.z1) - (0.58691951 * state.z2);
      const output = 0.02785977 * state.x1 + 0.05571953 * state.z1 + 0.02785977 * state.z2;
      state.z2 = state.z1;
      state.z1 = state.x1;
      return output;
    }
    
    function calculateBandPower(fftMagnitudes, freqRange) {
      const [startFreq, endFreq] = freqRange;
      const startIndex = Math.max(1, Math.floor(startFreq / FREQ_RESOLUTION));
      const endIndex = Math.min(Math.floor(endFreq / FREQ_RESOLUTION), fftMagnitudes.length - 1);
      let power = 0;
      for (let i = startIndex; i <= endIndex; i++) {
        power += fftMagnitudes[i] * fftMagnitudes[i];
      }
      return power;
    }
    
    function getSmoothedBeta(beta) {
      sum -= circular_buffer[data_index];
      sum += beta;
      circular_buffer[data_index] = beta;
      data_index = (data_index + 1) % buffer_size;
      return sum / buffer_size;
    }
    
    // Update brain wave display and balloon
    function updateBrainWaves(deltaP, thetaP, alphaP, betaP, gammaP) {
      const total = deltaP + thetaP + alphaP + betaP + gammaP;
      if (total <= 0) return;
      
      const deltaRel = deltaP / total;
      const thetaRel = thetaP / total;
      const alphaRel = alphaP / total;
      const betaRelInstant = betaP / total;
      const betaRel = getSmoothedBeta(betaRelInstant);
      const gammaRel = gammaP / total;

      // Update wave bars
      document.getElementById("deltaBar").style.width = `${Math.round(deltaRel * 100)}%`;
      document.getElementById("thetaBar").style.width = `${Math.round(thetaRel * 100)}%`;
      document.getElementById("alphaBar").style.width = `${Math.round(alphaRel * 100)}%`;
      document.getElementById("betaBar").style.width = `${Math.round(betaRel * 100)}%`;
      document.getElementById("gammaBar").style.width = `${Math.round(gammaRel * 100)}%`;

      document.getElementById("deltaValue").textContent = `${Math.round(deltaRel * 100)}%`;
      document.getElementById("thetaValue").textContent = `${Math.round(thetaRel * 100)}%`;
      document.getElementById("alphaValue").textContent = `${Math.round(betaRel * 100)}%`;
      document.getElementById("betaValue").textContent = `${Math.round(betaRel * 100)}%`;
      document.getElementById("gammaValue").textContent = `${Math.round(gammaRel * 100)}%`;

      // Update balloon based on beta value
      updateBalloon(betaRel);
    }
    
    function processFFT() {
      const fftMags = fftProcessor.computeMagnitudes(fftBuffer);
      const deltaPower = calculateBandPower(fftMags, DELTA_RANGE);
      const thetaPower = calculateBandPower(fftMags, THETA_RANGE);
      const alphaPower = calculateBandPower(fftMags, ALPHA_RANGE);
      const betaPower = calculateBandPower(fftMags, BETA_RANGE);
      const gammaPower = calculateBandPower(fftMags, GAMMA_RANGE);
      updateBrainWaves(deltaPower, thetaPower, alphaPower, betaPower, gammaPower);
    }
    
    function updateData(eegValue) {
      eegValue = notchFilterCh0.process(eegValue, 1);
      fftBuffer.push(eegValue);
      if (fftBuffer.length > FFT_SIZE) fftBuffer.shift();
      if (samplesReceived % 20 === 0) processFFT();
    }
    
    // Add visibility change handler for better tab switching behavior
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Tab is hidden - reduce processing
        buffer_size = 128;
      } else {
        // Tab is visible - normal processing
        buffer_size = 64;
      }
    });
    
    function processSample(dataView) {
      if (dataView.byteLength !== SINGLE_SAMPLE_LEN) return;

      const sampleCounter = dataView.getUint8(0);
      prevSampleCounter = sampleCounter;
      
      // Read EEG channel
      const rawEEG = dataView.getInt16(1, false);

      // Process EEG
      const normEEG = normalizeSample(Math.max(0, Math.min(4095, rawEEG)));
      const filteredEEG = applyFilter(normEEG, filterStateCh0);
      updateData(filteredEEG);
      samplesReceived++;
    }
    
    function handleNotification(event) {
      const value = event.target.value;
      if (value.byteLength === NEW_PACKET_LEN) {
        for (let i = 0; i < NEW_PACKET_LEN; i += SINGLE_SAMPLE_LEN) {
          const sampleBuf = value.buffer.slice(i, i + SINGLE_SAMPLE_LEN);
          processSample(new DataView(sampleBuf));
        }
      } else if (value.byteLength === SINGLE_SAMPLE_LEN) {
        processSample(new DataView(value.buffer));
      }
    }
    
    function updateButtonStates() {
      connectBtn.disabled = connected || streaming;
      disconnectBtn.disabled = !connected;
      startBtn.disabled = !connected || streaming;
      stopBtn.disabled = !streaming;

      if (!connected) statusText.textContent = "Not connected";
      else if (!streaming) statusText.textContent = "Connected but not streaming";
      else statusText.textContent = "Connected and streaming data";
    }
    
    async function connectBLE() {
      try {
        if (!navigator.bluetooth) {
          alert("Web Bluetooth API not available. Use Chrome or Edge.");
          return;
        }
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "NPG" }],
          optionalServices: [SERVICE_UUID],
        });
        server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        controlChar = await service.getCharacteristic(CONTROL_CHAR_UUID);
        dataChar = await service.getCharacteristic(DATA_CHAR_UUID);
        connected = true; streaming = false;
        fftBuffer = new Array(FFT_SIZE).fill(0);
        updateButtonStates();
        console.log("Device connected.");
      } catch (err) {
        console.log("Error:", err);
        alert("Connection error: " + err);
      }
    }
    
    async function disconnectBLE() {
      try {
        if (device && device.gatt.connected) {
          if (streaming) await stopStream();
          device.gatt.disconnect();
        }
        connected = false;
        streaming = false;
        updateButtonStates();
        console.log("Device disconnected.");
      } catch (err) {
        console.log("Error disconnecting:", err);
      }
    }
    
    async function startStream() {
      try {
        if (!dataChar || !controlChar) return;
        await controlChar.writeValue(new TextEncoder().encode("START"));
        await dataChar.startNotifications();
        dataChar.addEventListener("characteristicvaluechanged", handleNotification);
        streaming = true;
        updateButtonStates();
        console.log("Streaming started.");
        // Reset game stats
        score = 0;
        scoreValue.textContent = score;
        balloonSize = 1.0;
        balloon.style.transform = `scale(${balloonSize})`;
      } catch (err) {
        console.log("Error starting stream:", err);
        alert("Error starting stream: " + err);
      }
    }
    
    async function stopStream() {
      try {
        if (dataChar && streaming) {
          await dataChar.stopNotifications();
          dataChar.removeEventListener("characteristicvaluechanged", handleNotification);
          streaming = false;
          updateButtonStates();
          console.log("Streaming stopped.");
        }
      } catch (err) {
        console.log("Error stopping stream:", err);
      }
    }
    
    // Simulation functions for testing without EEG
    function simulateData() {
      if (!streaming) return;
      
      // Create random data with higher beta when user focuses
      const focused = Math.random() > 0.7;
      
      const deltaP = Math.random() * (focused ? 0.2 : 0.6);
      const thetaP = Math.random() * (focused ? 0.1 : 0.3);
      const alphaP = Math.random() * (focused ? 0.2 : 0.4);
      const betaP = Math.random() * (focused ? 0.8 : 0.2);
      const gammaP = Math.random() * (focused ? 0.4 : 0.1);
      
      updateBrainWaves(deltaP, thetaP, alphaP, betaP, gammaP);
    }
    
    // For testing without device
    let simulationInterval = null;
    
    // Event listeners for buttons
    connectBtn.addEventListener("click", () => {
      if (navigator.bluetooth) {
        connectBLE();
      } else {
        // Fallback for browsers without Web Bluetooth
        connected = true;
        streaming = false;
        updateButtonStates();
        alert("Web Bluetooth not available. Using simulation mode.");
      }
    });
    
    disconnectBtn.addEventListener("click", () => {
      if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
      }
      disconnectBLE();
    });
    
    startBtn.addEventListener("click", () => {
      if (navigator.bluetooth && device) {
        startStream();
      } else {
        // Simulation mode
        streaming = true;
        updateButtonStates();
        simulationInterval = setInterval(simulateData, 200);
      }
    });
    
    stopBtn.addEventListener("click", () => {
      if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
      }
      stopStream();
    });
    
    // Initialize
    updateButtonStates();
  </script>
</body>
</html>