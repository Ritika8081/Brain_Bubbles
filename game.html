<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EEG Focus Balloon</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: linear-gradient(to bottom, #0b486b, #0b3866);
      overflow: hidden;
      font-family: Arial, sans-serif;
      position: relative;
    }
    
    /* Underwater bubbles background */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="3" fill="rgba(255,255,255,0.2)"/><circle cx="50" cy="40" r="2" fill="rgba(255,255,255,0.15)"/><circle cx="80" cy="30" r="4" fill="rgba(255,255,255,0.1)"/><circle cx="30" cy="70" r="3" fill="rgba(255,255,255,0.2)"/><circle cx="70" cy="60" r="2" fill="rgba(255,255,255,0.15)"/><circle cx="10" cy="50" r="4" fill="rgba(255,255,255,0.1)"/></svg>');
      opacity: 0.6;
      z-index: 0;
      animation: bubbleFlow 20s linear infinite;
    }
    
    @keyframes bubbleFlow {
      0% { background-position: 0 0; }
      100% { background-position: 0 1000px; }
    }
    
    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1;
    }
    
    .balloon {
  position: absolute;
  width: 150px;
  height: 150px; /* Make height equal to width for perfect circle */
  background: radial-gradient(circle at 30% 30%, rgba(0,150,255,0.8), rgba(0,100,200,0.9));
  border-radius: 50%; /* Simple 50% for perfect circle */
  box-shadow: 
    inset -10px -10px 30px rgba(255,255,255,0.3),
    inset 10px 10px 30px rgba(0,0,0,0.2),
    0 0 20px rgba(0,200,255,0.5);
  transform-origin: center center; /* Center the transform origin */
  animation: float 3s ease-in-out infinite;
  z-index: 2;
  border: 2px solid rgba(255,255,255,0.3);
  overflow: hidden;
}
    
    /* Water reflection effect */
    .balloon::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 40%;
      background: radial-gradient(circle at 50% 0%, rgba(255,255,255,0.4), rgba(255,255,255,0));
      border-radius: 50%;
      filter: blur(5px);
    }
    
    .balloon::after {
      content: '';
      position: absolute;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 30px;
      background: rgba(255,255,255,0.5);
      border-radius: 0 0 5px 5px;
      z-index: 1;
    }
    
    .string {
      position: absolute;
      top: 185px;
      left: 75px;
      width: 2px;
      height: 120px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.8), transparent);
      z-index: 1;
    }
    
    .bubble {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(200,240,255,0.3));
      box-shadow: 0 0 10px rgba(255,255,255,0.8);
      animation: rise 4s linear forwards;
      z-index: 3;
    }
    
    .control-panel {
      position: absolute;
      bottom: 20px;
      background: rgba(0, 50, 100, 0.3);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      backdrop-filter: blur(5px);
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 1px solid rgba(0,200,255,0.3);
      z-index: 10;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .slider-label {
      color: white;
      margin-right: 10px;
      width: 120px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      width: 200px;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #00b4ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0,180,255,0.8);
    }
    
    .value-display {
      color: white;
      margin-left: 10px;
      min-width: 40px;
      text-align: right;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    button {
      background: rgba(0, 150, 255, 0.3);
      border: 1px solid rgba(0, 200, 255, 0.3);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
      margin: 5px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    button:hover:not(:disabled) {
      background: rgba(0, 180, 255, 0.5);
      box-shadow: 0 0 10px rgba(0,180,255,0.5);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: rgba(100, 100, 100, 0.3);
    }
    
    .status {
      color: white;
      margin-top: 10px;
      font-size: 14px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    .band-display {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 50, 100, 0.3);
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      display: flex;
      flex-direction: column;
      color: white;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      border: 1px solid rgba(0,200,255,0.3);
      z-index: 10;
    }
    
    .band-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .band-label {
      width: 80px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    .band-bar-container {
      width: 150px;
      height: 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
      overflow: hidden;
      margin: 0 10px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
    }
    
    .band-bar {
      height: 100%;
      border-radius: 10px;
      transition: width 0.3s;
      box-shadow: 0 0 5px rgba(255,255,255,0.3);
    }
    
    .delta-bar { background: #3498db; }
    .theta-bar { background: #2ecc71; }
    .alpha-bar { background: #f1c40f; }
    .beta-bar { background: #e74c3c; }
    .gamma-bar { background: #9b59b6; }
    
    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-10px) rotate(2deg); }
      50% { transform: translateY(-15px) rotate(0deg); }
      75% { transform: translateY(-10px) rotate(-2deg); }
    }
    
    @keyframes rise {
      0% { 
        opacity: 0.7; 
        transform: scale(0); 
      }
      20% { 
        opacity: 0.9; 
        transform: scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: translate(var(--tx), var(--ty)) scale(1.2);
      }
    }
    
    /* Underwater light rays */
    .light-ray {
      position: absolute;
      width: 2px;
      height: 150%;
      background: linear-gradient(to bottom, 
        transparent, 
        rgba(255,255,255,0.1), 
        transparent);
      transform: rotate(20deg);
      animation: rayMove 15s linear infinite;
      z-index: 0;
    }
    
    @keyframes rayMove {
      0% { transform: rotate(20deg) translateY(-100%); }
      100% { transform: rotate(20deg) translateY(100%); }
    }
  </style>
</head>
<body>
  <!-- Light rays for underwater effect -->
  <div class="light-ray" style="left: 10%; animation-delay: 0s;"></div>
  <div class="light-ray" style="left: 30%; animation-delay: 3s;"></div>
  <div class="light-ray" style="left: 50%; animation-delay: 6s;"></div>
  <div class="light-ray" style="left: 70%; animation-delay: 9s;"></div>
  <div class="light-ray" style="left: 90%; animation-delay: 12s;"></div>
  
  <div class="container">
    <div class="balloon"></div>
    <div class="string"></div>
  </div>
  
  <div class="band-display">
    <div class="band-row">
      <span class="band-label">Delta</span>
      <div class="band-bar-container">
        <div id="deltaBar" class="band-bar delta-bar" style="width: 0%;"></div>
      </div>
      <span id="deltaValue">0%</span>
    </div>
    <div class="band-row">
      <span class="band-label">Theta</span>
      <div class="band-bar-container">
        <div id="thetaBar" class="band-bar theta-bar" style="width: 0%;"></div>
      </div>
      <span id="thetaValue">0%</span>
    </div>
    <div class="band-row">
      <span class="band-label">Alpha</span>
      <div class="band-bar-container">
        <div id="alphaBar" class="band-bar alpha-bar" style="width: 0%;"></div>
      </div>
      <span id="alphaValue">0%</span>
    </div>
    <div class="band-row">
      <span class="band-label">Beta</span>
      <div class="band-bar-container">
        <div id="betaBar" class="band-bar beta-bar" style="width: 0%;"></div>
      </div>
      <span id="betaValue">0%</span>
    </div>
    <div class="band-row">
      <span class="band-label">Gamma</span>
      <div class="band-bar-container">
        <div id="gammaBar" class="band-bar gamma-bar" style="width: 0%;"></div>
      </div>
      <span id="gammaValue">0%</span>
    </div>
  </div>
  
  <div class="control-panel">
    <div class="slider-container">
      <span class="slider-label">Beta Threshold:</span>
      <input type="range" id="betaThresholdSlider" min="0.1" max="0.9" step="0.05" value="0.4">
      <span class="value-display" id="betaThresholdValue">0.40</span>
    </div>
    <div class="button-group">
      <button id="connectBtn">Connect Device</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <button id="startBtn" disabled>Start Stream</button>
      <button id="stopBtn" disabled>Stop Stream</button>
    </div>
    <div class="status" id="statusText">Not connected</div>
  </div>

  <!-- The rest of your JavaScript remains exactly the same -->
  <script>
   
    // DOM elements
    const balloon = document.querySelector('.balloon');
    const container = document.querySelector('.container');
    const betaThresholdSlider = document.getElementById('betaThresholdSlider');
    const betaThresholdValue = document.getElementById('betaThresholdValue');
    const connectBtn = document.getElementById("connectBtn");
    const disconnectBtn = document.getElementById("disconnectBtn");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const statusText = document.getElementById("statusText");
    
    // BLE constants
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const DATA_CHAR_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    const CONTROL_CHAR_UUID = "0000ff01-0000-1000-8000-00805f9b34fb";
    const SINGLE_SAMPLE_LEN = 7, BLOCK_COUNT = 10;
    const NEW_PACKET_LEN = SINGLE_SAMPLE_LEN * BLOCK_COUNT;
    
    // EEG processing constants
    const FFT_SIZE = 256;
    const SAMPLE_RATE = 500;
    const FREQ_RESOLUTION = SAMPLE_RATE / FFT_SIZE;
    const DELTA_RANGE = [0.5, 4];
    const THETA_RANGE = [4, 8];
    const ALPHA_RANGE = [8, 12];
    const BETA_RANGE = [12, 30];
    const GAMMA_RANGE = [30, 100];
    
    // Variables for BLE connection
    let device = null, server = null, controlChar = null, dataChar = null;
    let streaming = false, connected = false;
    let prevSampleCounter = null, samplesReceived = 0;
    
    // Variables for EEG processing
    let fftBuffer = new Array(FFT_SIZE).fill(0);
    let filterStateCh0 = { z1: 0, z2: 0, x1: 0 };
    let betaThreshold = 0.40;  // initial threshold
    
    // Buffer for smoothing beta values
    let buffer_size = 128;
    let circular_buffer = new Array(buffer_size).fill(0);
    let data_index = 0, sum = 0;
    
    // Notch filter for 50Hz noise
    class Notch {
      constructor() {
        this.z1_1 = 0; this.z2_1 = 0;
        this.x_1 = 0;
        this.currentSamplingRate = 500;
      }
      setSamplingRate(rate) { this.currentSamplingRate = rate; }
      process(input, type) {
        if (!type) return input;
        let output = input;
        // Simple example: 50Hz notch for 500Hz
        if (this.currentSamplingRate === 500 && type === 1) {
          this.x_1 = output - (-1.56858163 * this.z1_1) - (0.96424138 * this.z2_1);
          output = 0.96508099 * this.x_1 + -1.56202714 * this.z1_1 + 0.96508099 * this.z2_1;
          this.z2_1 = this.z1_1;
          this.z1_1 = this.x_1;
        }
        return output;
      }
    }
    let notchFilterCh0 = new Notch();
    notchFilterCh0.setSamplingRate(500);

    // FFT implementation
    class FFT {
      constructor(size) {
        this.size = size;
        this.cosTable = new Float32Array(size / 2);
        this.sinTable = new Float32Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
          this.cosTable[i] = Math.cos(-2 * Math.PI * i / size);
          this.sinTable[i] = Math.sin(-2 * Math.PI * i / size);
        }
      }
      computeMagnitudes(input) {
        const real = new Float32Array(this.size);
        const imag = new Float32Array(this.size);
        for (let i = 0; i < input.length && i < this.size; i++) {
          real[i] = input[i];
        }
        this.fft(real, imag);
        const mags = new Float32Array(this.size / 2);
        for (let i = 0; i < this.size / 2; i++) {
          mags[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / (this.size / 2);
        }
        return mags;
      }
      fft(real, imag) {
        const n = this.size;
        let j = 0;
        for (let i = 0; i < n - 1; i++) {
          if (i < j) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], real[i]];
          }
          let k = n / 2;
          while (k <= j) { j -= k; k /= 2; }
          j += k;
        }
        for (let l = 2; l <= n; l *= 2) {
          const le2 = l / 2;
          for (let k = 0; k < le2; k++) {
            const kth = k * (n / l);
            const c = this.cosTable[kth], s = this.sinTable[kth];
            for (let i = k; i < n; i += l) {
              const i2 = i + le2;
              const tr = c * real[i2] - s * imag[i2];
              const ti = c * imag[i2] + s * real[i2];
              real[i2] = real[i] - tr;
              imag[i2] = imag[i] - ti;
              real[i] += tr;
              imag[i] += ti;
            }
          }
        }
      }
    }
    const fftProcessor = new FFT(FFT_SIZE);
    
    // Update threshold value from slider
    betaThresholdSlider.addEventListener('input', (e) => {
      betaThreshold = parseFloat(e.target.value);
      betaThresholdValue.textContent = betaThreshold.toFixed(2);
    });
    
    // Create bubbles when beta threshold is exceeded
    function createFocusBubbles() {
      if (Date.now() - lastBubbleTime < 500) return; // Max 2 bubbles per second
  lastBubbleTime = Date.now();
  // Reduce number of bubbles
  const bubbleCount = Math.floor(Math.random() * 3) + 2; // 2-4 bubbles

      for (let i = 0; i < bubbleCount; i++) {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        
        // Random size between 10px and 40px
        const size = Math.floor(Math.random() * 30) + 10;
        bubble.style.width = `${size}px`;
        bubble.style.height = `${size}px`;
        
        // Position bubble at balloon center
        const balloonRect = balloon.getBoundingClientRect();
        const startX = balloonRect.left + balloonRect.width / 2 - size / 2;
        const startY = balloonRect.top + balloonRect.height / 2 - size / 2;
        
        bubble.style.left = `${startX}px`;
        bubble.style.top = `${startY}px`;
        
        // Set random direction for bubble to travel
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * 200;
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance - 100; // Mostly upward
        
        bubble.style.setProperty('--tx', `${tx}px`);
        bubble.style.setProperty('--ty', `${ty}px`);
        
        // Remove bubble after animation completes
        bubble.addEventListener('animationend', () => {
          bubble.remove();
        });
        
        document.body.appendChild(bubble);
      }
    }
    
    // Expose bubble creation function globally
    window.createFocusBubbles = createFocusBubbles;
    
    // Utility functions from the original code
    function normalizeSample(sample) {
      const a = 4096;
      return (sample - a / 2) * (2 / a);
    }
    
    function applyFilter(input, state) {
      state.x1 = input - (-1.47548044 * state.z1) - (0.58691951 * state.z2);
      const output = 0.02785977 * state.x1 + 0.05571953 * state.z1 + 0.02785977 * state.z2;
      state.z2 = state.z1;
      state.z1 = state.x1;
      return output;
    }
    
    function calculateBandPower(fftMagnitudes, freqRange) {
      const [startFreq, endFreq] = freqRange;
      const startIndex = Math.max(1, Math.floor(startFreq / FREQ_RESOLUTION));
      const endIndex = Math.min(Math.floor(endFreq / FREQ_RESOLUTION), fftMagnitudes.length - 1);
      let power = 0;
      for (let i = startIndex; i <= endIndex; i++) {
        power += fftMagnitudes[i] * fftMagnitudes[i];
      }
      return power;
    }
    
    function getSmoothedBeta(beta) {
      sum -= circular_buffer[data_index];
      sum += beta;
      circular_buffer[data_index] = beta;
      data_index = (data_index + 1) % buffer_size;
      return sum / buffer_size;
    }
    
    function updateBarGraph(deltaP, thetaP, alphaP, betaP, gammaP) {
      const total = deltaP + thetaP + alphaP + betaP + gammaP;
      if (total <= 0) return;
      
      const deltaRel = deltaP / total;
      const thetaRel = thetaP / total;
      const alphaRel = alphaP / total;
      const betaRel = getSmoothedBeta(betaP / total);
      const gammaRel = gammaP / total;

      // Update horizontal bar chart
      document.getElementById("deltaBar").style.width = `${Math.round(deltaRel * 100)}%`;
      document.getElementById("thetaBar").style.width = `${Math.round(thetaRel * 100)}%`;
      document.getElementById("alphaBar").style.width = `${Math.round(alphaRel * 100)}%`;
      document.getElementById("betaBar").style.width = `${Math.round(betaRel * 100)}%`;
      document.getElementById("gammaBar").style.width = `${Math.round(gammaRel * 100)}%`;

      document.getElementById("deltaValue").textContent = `${Math.round(deltaRel * 100)}%`;
      document.getElementById("thetaValue").textContent = `${Math.round(thetaRel * 100)}%`;
      document.getElementById("alphaValue").textContent = `${Math.round(alphaRel * 100)}%`;
      document.getElementById("betaValue").textContent = `${Math.round(betaRel * 100)}%`;
      document.getElementById("gammaValue").textContent = `${Math.round(gammaRel * 100)}%`;

      // Create bubbles when beta threshold is exceeded
      if (betaRel >= betaThreshold) {
        createFocusBubbles();
      }
    }
    
    function processFFT() {
      const fftMags = fftProcessor.computeMagnitudes(fftBuffer);
      const deltaPower = calculateBandPower(fftMags, DELTA_RANGE);
      const thetaPower = calculateBandPower(fftMags, THETA_RANGE);
      const alphaPower = calculateBandPower(fftMags, ALPHA_RANGE);
      const betaPower = calculateBandPower(fftMags, BETA_RANGE);
      const gammaPower = calculateBandPower(fftMags, GAMMA_RANGE);
      updateBarGraph(deltaPower, thetaPower, alphaPower, betaPower, gammaPower);
    }
    
    function updateData(eegValue) {
      eegValue = notchFilterCh0.process(eegValue, 1);
      fftBuffer.push(eegValue);
      if (fftBuffer.length > FFT_SIZE) fftBuffer.shift();
      if (samplesReceived % 20 === 0) processFFT();
    }
    
    function processSample(dataView) {
      if (dataView.byteLength !== SINGLE_SAMPLE_LEN) return;

      const sampleCounter = dataView.getUint8(0);
      prevSampleCounter = sampleCounter;
      
      // Read EEG channel
      const rawEEG = dataView.getInt16(1, false);

      // Process EEG
      const normEEG = normalizeSample(Math.max(0, Math.min(4095, rawEEG)));
      const filteredEEG = applyFilter(normEEG, filterStateCh0);
      updateData(filteredEEG);
      samplesReceived++;
    }
    
    function handleNotification(event) {
      const value = event.target.value;
      if (value.byteLength === NEW_PACKET_LEN) {
        for (let i = 0; i < NEW_PACKET_LEN; i += SINGLE_SAMPLE_LEN) {
          const sampleBuf = value.buffer.slice(i, i + SINGLE_SAMPLE_LEN);
          processSample(new DataView(sampleBuf));
        }
      } else if (value.byteLength === SINGLE_SAMPLE_LEN) {
        processSample(new DataView(value.buffer));
      }
    }
    
    function updateButtonStates() {
      connectBtn.disabled = connected || streaming;
      disconnectBtn.disabled = !connected;
      startBtn.disabled = !connected || streaming;
      stopBtn.disabled = !streaming;

      if (!connected) statusText.textContent = "Not connected";
      else if (!streaming) statusText.textContent = "Connected but not streaming";
      else statusText.textContent = "Connected and streaming data";
    }
    
    async function connectBLE() {
      try {
        if (!navigator.bluetooth) {
          alert("Web Bluetooth API not available. Use Chrome or Edge.");
          return;
        }
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "NPG" }],
          optionalServices: [SERVICE_UUID],
        });
        server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        controlChar = await service.getCharacteristic(CONTROL_CHAR_UUID);
        dataChar = await service.getCharacteristic(DATA_CHAR_UUID);
        connected = true; streaming = false;
        fftBuffer = new Array(FFT_SIZE).fill(0);
        updateButtonStates();
        console.log("Device connected.");
      } catch (err) {
        console.log("Error:", err);
        alert("Connection error: " + err);
      }
    }
    
    async function disconnectBLE() {
      try {
        if (device && device.gatt.connected) {
          if (streaming) await stopStream();
          device.gatt.disconnect();
        }
        connected = false;
        streaming = false;
        updateButtonStates();
        console.log("Device disconnected.");
      } catch (err) {
        console.log("Error disconnecting:", err);
      }
    }
    
    async function startStream() {
      try {
        if (!dataChar || !controlChar) return;
        await controlChar.writeValue(new TextEncoder().encode("START"));
        await dataChar.startNotifications();
        dataChar.addEventListener("characteristicvaluechanged", handleNotification);
        streaming = true;
        updateButtonStates();
        console.log("Streaming started.");
      } catch (err) {
        console.log("Error starting stream:", err);
        alert("Error starting stream: " + err);
      }
    }
    
    async function stopStream() {
      try {
        if (dataChar && streaming) {
          await dataChar.stopNotifications();
          dataChar.removeEventListener("characteristicvaluechanged", handleNotification);
          streaming = false;
          updateButtonStates();
          console.log("Streaming stopped.");
        }
      } catch (err) {
        console.log("Error stopping stream:", err);
      }
    }
    
    // Event listeners for buttons
    connectBtn.addEventListener("click", connectBLE);
    disconnectBtn.addEventListener("click", disconnectBLE);
    startBtn.addEventListener("click", startStream);
    stopBtn.addEventListener("click", stopStream);
  </script>
</body>
</html>